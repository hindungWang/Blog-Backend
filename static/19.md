---
Id: 19
Title: Goæºç è§£è¯»ä¹‹sync.Cond
Date: äº”æœˆä¸€åé™†
Year: 2021
Summary: Goæºç æ¢ç©¶ç³»åˆ—ï¼ŒåŸºäºgolang 1.16.xç‰ˆæœ¬
Tags:
  - Go
---
## å‰è¨€

[å‰é¢ğŸ”—](https://hindung.cn/blog/2021/18)è¯´è¿‡ï¼ŒCondå®ç°äº†ä¸€ä¸ªæ¡ä»¶å˜é‡ï¼Œæ˜¯ç­‰å¾…æˆ–å®£å¸ƒä¸€ä¸ªäº‹ä»¶å‘ç”Ÿçš„goroutinesçš„æ±‡åˆç‚¹ã€‚

å°±æ˜¯è¯´ï¼Œä½¿ç”¨sync.Condå¯ä»¥åšåˆ°å¤šä¸ªåç¨‹ç­‰å¾…æŸä¸ªåç¨‹é€šçŸ¥çš„åœºæ™¯ã€‚

ä½¿ç”¨channelå¯ä»¥å®ç°ä¸€è¯»ä¸€å†™çš„åœºæ™¯ï¼Œè€ŒCondåˆ™å®ç°å¤šè¯»ä¸€å†™çš„åœºæ™¯ã€‚

## æºç è§£æ

ç®€åŒ–ç‰ˆæ–¹æ³•ç­¾åï¼š
```go
// Condç»“æ„ä½“
type Cond struct {}

// NewCond è¿”å›å¸¦Lockerçš„Condï¼Œè¿™ä¸ªLockerå¯ä»¥æ˜¯
// *Mutex æˆ– *RWMutex
func NewCond(l Locker) *Cond {}

// ç­‰å¾…Lçš„è§£é”å¹¶æŒ‚èµ·goroutine
func (c *Cond) Wait() {}

// å”¤é†’1ä¸ªå› cé˜»å¡çš„goroutineï¼Œ
// å¦‚æœåœ¨Signalä¹‹åæ‰Waitä¼šå¯¼è‡´all goroutines are asleep - deadlock
func (c *Cond) Signal() {}

// å”¤é†’æ‰€æœ‰å› cé˜»å¡çš„goroutine
// å¦‚æœåœ¨Broadcastä¹‹åæ‰Waitä¼šå¯¼è‡´all goroutines are asleep - deadlock
func (c *Cond) Broadcast() {}
```

å› æ­¤ï¼Œåœ¨Signalæˆ–è€…Broadcastå‰è¦å…ˆä¿è¯ç›®æ ‡çš„åç¨‹å·²ç»è¿›å…¥äº†WaitçŠ¶æ€ï¼Œå¦åˆ™ä¼šå¯¼è‡´æ­»é”ã€‚å› ä¸ºSignalæˆ–è€…Broadcaståªå”¤é†’å½“å‰æ­£åœ¨è¢«Waité˜»å¡çš„åç¨‹ã€‚

[Condçš„å®šä¹‰](https://go.googlesource.com/go/+/go1.16.4/src/sync/cond.go#21)ï¼š
```go
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package sync
import (
	"sync/atomic"
	"unsafe"
)
// Cond implements a condition variable, a rendezvous point
// for goroutines waiting for or announcing the occurrence
// of an event.
// Condå®ç°äº†ä¸€ä¸ªæ¡ä»¶å˜é‡ï¼Œå®ƒæ˜¯goroutinesç­‰å¾…æˆ–å®£å¸ƒäº‹ä»¶å‘ç”Ÿçš„é›†åˆç‚¹ã€‚

// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
// which must be held when changing the condition and
// when calling the Wait method.
// æ¯ä¸ªCondéƒ½æœ‰ä¸€ä¸ªç›¸å…³çš„Locker Lï¼ˆé€šå¸¸æ˜¯ä¸€ä¸ª*Mutexæˆ–*RWMutexï¼‰ï¼Œ
// åœ¨æ”¹å˜æ¡ä»¶å’Œè°ƒç”¨Waitæ–¹æ³•æ—¶ï¼Œå¿…é¡»æŒæœ‰è¿™ä¸ªLã€‚
// A Cond must not be copied after first use.
type Cond struct {
	noCopy noCopy
	// L is held while observing or changing the condition
	L Locker
	// notifyListæ˜¯ç”¨äºå®ç°sync.Condçš„åŸºäºç¥¨è¯çš„é€šçŸ¥åˆ—è¡¨
	// å‚è€ƒï¼š
	// https://go.googlesource.com/go/+/go1.16.4/src/runtime/sema.go#446
	notify  notifyList
	checker copyChecker
}
// NewCond returns a new Cond with Locker l.
func NewCond(l Locker) *Cond {
	return &Cond{L: l}
}
// Wait atomically unlocks c.L and suspends execution
// of the calling goroutine. After later resuming execution,
// Wait locks c.L before returning. Unlike in other systems,
// Wait cannot return unless awoken by Broadcast or Signal.
//
// Because c.L is not locked when Wait first resumes, the caller
// typically cannot assume that the condition is true when
// Wait returns. Instead, the caller should Wait in a loop:
//
//    c.L.Lock()
//    for !condition() {
//        c.Wait()
//    }
//    ... make use of condition ...
//    c.L.Unlock()
//

// Waitä¼šå…ˆæŠŠåŠ å…¥åˆ°å¾…å”¤é†’é˜Ÿåˆ—ï¼Œå†é‡Šæ”¾é”ï¼Œç„¶åæ‰§è¡Œç­‰å¾…ï¼Œ
// å½“å…¶ä»–goroutineè°ƒç”¨Broadcastæˆ–è€…Signalæ¥é€šçŸ¥å…¶æ¢å¤æ‰§è¡Œåï¼Œ
// ä¼šé‡æ–°ä¸Šé”
func (c *Cond) Wait() {
	c.checker.check()
	// notifyListAddå°†è°ƒç”¨è€…æ·»åŠ åˆ°é€šçŸ¥åˆ—è¡¨ä¸­ï¼Œä»¥ä¾¿å®ƒå¯ä»¥æ¥æ”¶é€šçŸ¥ã€‚
	// è°ƒç”¨è€…å¿…é¡»æœ€ç»ˆè°ƒç”¨notifyListWaitæ¥ç­‰å¾…è¿™æ ·çš„é€šçŸ¥ï¼Œå¹¶æ˜¾å¼ä¼ å‚ã€‚
	// å‚è€ƒï¼š
	// https://go.googlesource.com/go/+/go1.16.4/src/sync/runtime.go#31
	// https://go.googlesource.com/go/+/go1.16.4/src/runtime/sema.go#475
	t := runtime_notifyListAdd(&c.notify)
	c.L.Unlock()
	// notifyListWaitç­‰å¾…é€šçŸ¥ã€‚å¦‚æœè‡ªé‚£ä»¥åå·²å‘é€ï¼Œ
    // è°ƒç”¨notifyListAddï¼Œå®ƒç«‹å³è¿”å›ã€‚å¦åˆ™ï¼Œå®ƒå°†é˜»å¡ã€‚
	// å‚è€ƒï¼š
	// https://go.googlesource.com/go/+/go1.16.4/src/sync/runtime.go#34
	// https://go.googlesource.com/go/+/go1.16.4/src/runtime/sema.go#485
	runtime_notifyListWait(&c.notify, t)
	c.L.Lock()
}
// Signal wakes one goroutine waiting on c, if there is any.
//
// It is allowed but not required for the caller to hold c.L
// during the call.
func (c *Cond) Signal() {
	c.checker.check()
	runtime_notifyListNotifyOne(&c.notify)
}
// Broadcast wakes all goroutines waiting on c.
//
// It is allowed but not required for the caller to hold c.L
// during the call.
func (c *Cond) Broadcast() {
	c.checker.check()
	runtime_notifyListNotifyAll(&c.notify)
}
// copyChecker holds back pointer to itself to detect object copying.
type copyChecker uintptr
func (c *copyChecker) check() {
	if uintptr(*c) != uintptr(unsafe.Pointer(c)) &&
		!atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) &&
		uintptr(*c) != uintptr(unsafe.Pointer(c)) {
		panic("sync.Cond is copied")
	}
}
// noCopy may be embedded into structs which must not be copied
// after the first use.
//
// See https://golang.org/issues/8005#issuecomment-190753527
// for details.
type noCopy struct{}
// Lock is a no-op used by -copylocks checker from `go vet`.
func (*noCopy) Lock()   {}
func (*noCopy) Unlock() {}
```

## ä½¿ç”¨ä¾‹å­

å¯ä»¥æŒ‰ç…§å®˜æ–¹ç»™çš„ä½¿ç”¨ä¾‹å­ï¼š
```go
//    c.L.Lock()
//    æŸä¸ªæ¡ä»¶æ»¡è¶³æ‰è¿›è¡ŒWaitï¼Œå¦åˆ™å¯èƒ½ä¼šå¯¼è‡´Waitå‘ç”Ÿåœ¨
//    å”¤é†’ä¹‹åï¼Œä»è€Œå¯¼è‡´æ­»é”
//    for !condition() {  
//        c.Wait()
//    }
//    ... make use of condition ...
//    c.L.Unlock()
```

å¦‚ï¼š
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var locker = new(sync.Mutex)
var cond = sync.NewCond(locker)
var condition = false

func main() {
	var wg sync.WaitGroup
	wg.Add(10)
    for i := 0; i < 10; i++ {
        go func(x int) {
            cond.L.Lock()         //è·å–é”
            defer cond.L.Unlock() //é‡Šæ”¾é”
			for !condition {
				cond.Wait()
			}
            fmt.Println(x)
			wg.Done()
        }(i)
    }   
    time.Sleep(time.Second * 3)
	cond.L.Lock()
	condition = true
    cond.Broadcast()  
	cond.L.Unlock()
	wg.Wait()         
}
```

æ³¨æ„ï¼šsync.Condéœ€è¦å¼€å‘äººå‘˜æŠŠæ¡é”ä»¥åŠcondition()çš„æ¡ä»¶ï¼Œæ¯”è¾ƒå®¹æ˜“å‘ç”Ÿæ­»é”ã€‚

## å…¶ä»–ä»£ç ä¸­çš„åº”ç”¨

k8sä¸­çš„client-goä»£ç ä¸­çš„[DeltaFIFOé˜Ÿåˆ—](https://github.com/kubernetes/client-go/blob/v0.21.0/tools/cache/delta_fifo.go#L98)å®ç°å°±æ˜¯ç”¨äº†sync.Condæ¥å®ç°ï¼š
```go
type DeltaFIFO struct {
	// lock/cond protects access to 'items' and 'queue'.
	lock sync.RWMutex
	cond sync.Cond

	// å…¶ä»–å­—æ®µçœç•¥
}
```

[åˆå§‹åŒ–](https://github.com/kubernetes/client-go/blob/v0.21.0/tools/cache/delta_fifo.go#L207)ï¼š
```go
func NewDeltaFIFO(keyFunc KeyFunc, knownObjects KeyListerGetter) *DeltaFIFO {
	return NewDeltaFIFOWithOptions(DeltaFIFOOptions{
		KeyFunction:  keyFunc,
		KnownObjects: knownObjects,
	})
}

func NewDeltaFIFOWithOptions(opts DeltaFIFOOptions) *DeltaFIFO {
	if opts.KeyFunction == nil {
		opts.KeyFunction = MetaNamespaceKeyFunc
	}

	f := &DeltaFIFO{
		items:        map[string]Deltas{},
		queue:        []string{},
		keyFunc:      opts.KeyFunction,
		knownObjects: opts.KnownObjects,

		emitDeltaTypeReplaced: opts.EmitDeltaTypeReplaced,
	}
	// f.lock ä¸ f.cond ç»“åˆä½¿ç”¨
	f.cond.L = &f.lock
	return f
}
```

å†æ¥çœ‹çœ‹[Popæ–¹æ³•](https://github.com/kubernetes/client-go/blob/v0.21.0/tools/cache/delta_fifo.go#L518)ï¼Œä½•æ—¶è°ƒç”¨Waitï¼š
```go
// Popé˜»å¡ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸­æœ‰ä¸€äº›é¡¹ç›®ï¼Œç„¶åè¿”å›ä¸€ä¸ªã€‚
// å¦‚æœå¤šä¸ªé¡¹ç›®å‡†å¤‡å°±ç»ªï¼Œå®ƒä»¬å°†æŒ‰ç…§å®ƒä»¬è¢«æ·»åŠ /æ›´æ–°çš„é¡ºåºè¿”å›ã€‚
func (f *DeltaFIFO) Pop(process PopProcessFunc) (interface{}, error) {
	f.lock.Lock()
	defer f.lock.Unlock()
	for {
		// æœ‰æ•°æ®å°±ä¸ç”¨Wait
		for len(f.queue) == 0 {
			// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
			// å½“é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œå°†é˜»æ­¢Popï¼ˆï¼‰çš„è°ƒç”¨ï¼Œç›´åˆ°æ–°é¡¹ç›®å…¥é˜Ÿã€‚
			// When Close() is called, the f.closed is set and the condition is broadcasted.
			// å½“Close()è¢«è°ƒç”¨æ—¶ï¼Œf.closedè¢«è®¾ç½®ï¼Œæ¡ä»¶è¢«å¹¿æ’­ã€‚
			// Which causes this loop to continue and return from the Pop().
			if f.closed {
				return nil, ErrFIFOClosed
			}

			// é˜»å¡ç›´åˆ°è¢«å¹¿æ’­ï¼ˆè¯´æ˜æœ‰æ•°æ®ï¼‰
			f.cond.Wait()
		}
		id := f.queue[0]
		f.queue = f.queue[1:]
		if f.initialPopulationCount > 0 {
			f.initialPopulationCount--
		}
		item, ok := f.items[id]
		if !ok {
			// This should never happen
			klog.Errorf("Inconceivable! %q was in f.queue but not f.items; ignoring.", id)
			continue
		}
		delete(f.items, id)
		err := process(item)
		if e, ok := err.(ErrRequeue); ok {
			f.addIfNotPresent(id, item)
			err = e.Err
		}
		// Don't need to copyDeltas here, because we're transferring
		// ownership to the caller.
		return item, err
	}
}
```

ä½•æ—¶è°ƒç”¨Broadcastï¼š
```go
// Close the queue.
func (f *DeltaFIFO) Close() {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.closed = true
	f.cond.Broadcast()
}

// addIfNotPresent inserts deltas under id if it does not exist, and assumes the caller
// already holds the fifo lock.
func (f *DeltaFIFO) addIfNotPresent(id string, deltas Deltas) {
	f.populated = true
	if _, exists := f.items[id]; exists {
		return
	}

	f.queue = append(f.queue, id)
	f.items[id] = deltas
	// æœ‰æ•°æ®ï¼Œåˆ™å¹¿æ’­
	f.cond.Broadcast()
}

// queueActionLocked appends to the delta list for the object.
// queueActionLockedè¿½åŠ åˆ°è¯¥å¯¹è±¡çš„deltaåˆ—è¡¨ã€‚
// Caller must lock first.
func (f *DeltaFIFO) queueActionLocked(actionType DeltaType, obj interface{}) error {
	id, err := f.KeyOf(obj)
	if err != nil {
		return KeyError{obj, err}
	}
	oldDeltas := f.items[id]
	newDeltas := append(oldDeltas, Delta{actionType, obj})
	newDeltas = dedupDeltas(newDeltas)

	if len(newDeltas) > 0 {
		if _, exists := f.items[id]; !exists {
			f.queue = append(f.queue, id)
		}
		f.items[id] = newDeltas
		f.cond.Broadcast()
	} else {
		// This never happens, because dedupDeltas never returns an empty list
		// when given a non-empty list (as it is here).
		// If somehow it happens anyway, deal with it but complain.
		if oldDeltas == nil {
			klog.Errorf("Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; ignoring", id, oldDeltas, obj)
			return nil
		}
		klog.Errorf("Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; breaking invariant by storing empty Deltas", id, oldDeltas, obj)
		f.items[id] = newDeltas
		return fmt.Errorf("Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; broke DeltaFIFO invariant by storing empty Deltas", id, oldDeltas, obj)
	}
	return nil
}
```


*æ›´æ–°äº 2021/05/16 23:53*