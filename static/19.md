---
Id: 19
Title: Goæºç è§£è¯»ä¹‹sync.Cond
Date: äº”æœˆä¸€åé™†
Year: 2021
Summary: Goæºç æ¢ç©¶ç³»åˆ—ï¼ŒåŸºäºgolang 1.16.xç‰ˆæœ¬
Tags:
  - Go
---
## å‰è¨€

[å‰é¢ğŸ”—](https://hindung.cn/blog/2021/18)è¯´è¿‡ï¼ŒCondå®ç°äº†ä¸€ä¸ªæ¡ä»¶å˜é‡ï¼Œæ˜¯ç­‰å¾…æˆ–å®£å¸ƒä¸€ä¸ªäº‹ä»¶å‘ç”Ÿçš„goroutinesçš„æ±‡åˆç‚¹ã€‚

å°±æ˜¯è¯´ï¼Œä½¿ç”¨sync.Condå¯ä»¥åšåˆ°å¤šä¸ªåç¨‹ç­‰å¾…æŸä¸ªåç¨‹é€šçŸ¥çš„åœºæ™¯ã€‚

ä½¿ç”¨channelå¯ä»¥å®ç°ä¸€è¯»ä¸€å†™çš„åœºæ™¯ï¼Œè€ŒCondåˆ™å®ç°å¤šè¯»ä¸€å†™çš„åœºæ™¯ã€‚

## æºç è§£æ

ç®€åŒ–ç‰ˆæ–¹æ³•ç­¾åï¼š
```go
// Condç»“æ„ä½“
type Cond struct {}

// NewCond è¿”å›å¸¦Lockerçš„Condï¼Œè¿™ä¸ªLockerå¯ä»¥æ˜¯
// *Mutex æˆ– *RWMutex
func NewCond(l Locker) *Cond {}

// ç­‰å¾…Lçš„è§£é”å¹¶æŒ‚èµ·goroutine
func (c *Cond) Wait() {}

func (c *Cond) Signal() {}

func (c *Cond) Broadcast() {}
```

[Condçš„å®šä¹‰](https://go.googlesource.com/go/+/go1.16.4/src/sync/cond.go#21)ï¼š
```go
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package sync
import (
	"sync/atomic"
	"unsafe"
)
// Cond implements a condition variable, a rendezvous point
// for goroutines waiting for or announcing the occurrence
// of an event.
// Condå®ç°äº†ä¸€ä¸ªæ¡ä»¶å˜é‡ï¼Œå®ƒæ˜¯goroutinesç­‰å¾…æˆ–å®£å¸ƒäº‹ä»¶å‘ç”Ÿçš„é›†åˆç‚¹ã€‚

// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
// which must be held when changing the condition and
// when calling the Wait method.
// æ¯ä¸ªCondéƒ½æœ‰ä¸€ä¸ªç›¸å…³çš„Locker Lï¼ˆé€šå¸¸æ˜¯ä¸€ä¸ª*Mutexæˆ–*RWMutexï¼‰ï¼Œ
// åœ¨æ”¹å˜æ¡ä»¶å’Œè°ƒç”¨Waitæ–¹æ³•æ—¶ï¼Œå¿…é¡»æŒæœ‰è¿™ä¸ªLã€‚
// A Cond must not be copied after first use.
type Cond struct {
	noCopy noCopy
	// L is held while observing or changing the condition
	L Locker
	notify  notifyList
	checker copyChecker
}
// NewCond returns a new Cond with Locker l.
func NewCond(l Locker) *Cond {
	return &Cond{L: l}
}
// Wait atomically unlocks c.L and suspends execution
// of the calling goroutine. After later resuming execution,
// Wait locks c.L before returning. Unlike in other systems,
// Wait cannot return unless awoken by Broadcast or Signal.
//
// Because c.L is not locked when Wait first resumes, the caller
// typically cannot assume that the condition is true when
// Wait returns. Instead, the caller should Wait in a loop:
//
//    c.L.Lock()
//    for !condition() {
//        c.Wait()
//    }
//    ... make use of condition ...
//    c.L.Unlock()
//
func (c *Cond) Wait() {
	c.checker.check()
	t := runtime_notifyListAdd(&c.notify)
	c.L.Unlock()
	runtime_notifyListWait(&c.notify, t)
	c.L.Lock()
}
// Signal wakes one goroutine waiting on c, if there is any.
//
// It is allowed but not required for the caller to hold c.L
// during the call.
func (c *Cond) Signal() {
	c.checker.check()
	runtime_notifyListNotifyOne(&c.notify)
}
// Broadcast wakes all goroutines waiting on c.
//
// It is allowed but not required for the caller to hold c.L
// during the call.
func (c *Cond) Broadcast() {
	c.checker.check()
	runtime_notifyListNotifyAll(&c.notify)
}
// copyChecker holds back pointer to itself to detect object copying.
type copyChecker uintptr
func (c *copyChecker) check() {
	if uintptr(*c) != uintptr(unsafe.Pointer(c)) &&
		!atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) &&
		uintptr(*c) != uintptr(unsafe.Pointer(c)) {
		panic("sync.Cond is copied")
	}
}
// noCopy may be embedded into structs which must not be copied
// after the first use.
//
// See https://golang.org/issues/8005#issuecomment-190753527
// for details.
type noCopy struct{}
// Lock is a no-op used by -copylocks checker from `go vet`.
func (*noCopy) Lock()   {}
func (*noCopy) Unlock() {}
```

## ä½¿ç”¨ä¾‹å­

## å…¶ä»–ä»£ç ä¸­çš„åº”ç”¨

*æ›´æ–°äº 2021/05/16 23:53*