--- 
Id: 13
Title: 使用Go遇到的坑
Date: 肆月贰
Year: 2021
Summary: Go用了这么久，肯定遇到什么奇奇怪怪的坑吧？
Tags:
  - Go
--- 

## for range 语句中的值传递问题
```go
package main

import "fmt"

var pow = []int{1, 2, 4}

func main() {
	for _, v := range pow {
		v++
	}
	for _, v := range pow {
		fmt.Println(v)
	}
}
//out put : 1  2  4
```
原因：for range创建了每个元素的副本，而不是直接返回每个元素的引用。

## IPv4与IPv6格式问题 
Go中IPv4的长度和IPv6的长度是一样的，都是16Byte存储，故不能使用len()函数去区别:
```go

conn, err := net.Dial("udp", "8.9.10.11:2342")
if err != nil {
    fmt.Println("Error", err)
}

localaddr := conn.LocalAddr()

addr, _ := net.ResolveUDPAddr("udp", localaddr.String())

ip := addr.IP

fmt.Println(ip)
fmt.Println(len(ip))
```
详情请点击链接：[golang-distinguish-ipv4-ipv6](https://stackoverflow.com/questions/22751035/golang-distinguish-ipv4-ipv6)

## transport使用不当导致不能共享tcp连接池，进而导致tcp连接过多

```go
// 初始化一个 http.Client
func getClient() *http.Client  {
	return &http.Client{
		Transport:     &http.Transport{  // 自定义 Transport
			TLSClientConfig:        &tls.Config{InsecureSkipVerify: true},
		},
		Timeout:       5 * time.Second,
	}
}

func Post(url string) ([]byte, error) {
	client := getClient()
	req, err := http.NewRequest("POST", url, strings.NewReader("test"))
	if err != nil {
		return nil, err
	}
	httpRet, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer httpRet.Body.Close()
	var body []byte
	body, err = ioutil.ReadAll(httpRet.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}
```
代码存在问题：1、每次发请求都会创建一次连接；2、请求结束后没有及时释放连接；3、导致tcp连接暴涨

原因：实例化transport时没有处理连接池问题，导致每次初始化都会使用新的连接。如果没有默认transport，实例化的client会使用一个default的transport，并且已经实现了池化。

此外，如果请求的body没有完全读出，将会导致tcp连接不能服用。

## 野生goroutine没有recover导致整个程序退出

使用gin时虽然会有上层的recover会对panic异常做兜底，但是对于自己定义的goroutine如果没有做recover就会导致整个程序垮掉：
```go
r.GET("/panic1", func (c *gin.Context) {
		var s *int
		fmt.Println(*s)  // 制造空指针panic，这里会被gin上层的recover兜住，不会整个程序退出
	})
r.GET("/panic2", func (c *gin.Context) {
		// 野生 goroutine
        go func() {
			var s *int
			fmt.Println(*s)  // 这里会导致panic，整个程序退出
		}()
	})

// 应该这样
r.GET("/panic3", func (c *gin.Context) {
		// 野生 goroutine
        go func() {
			// 定义recover兜住panic
			defer func() {
				if err := recover(); err != nil {
					fmt.Println("recover success")
				}
			}
			var s *int
			fmt.Println(*s)  // 这里会导致panic，整个程序退出
		}()
	})
```

